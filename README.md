# COMP - Project 1

# Setup Instructions

For this project, you need to [install Gradle](https://gradle.org/install/)

## Project setup

Copy your ``.jjt`` file to the ``javacc`` folder. If you change any of the classes generated by ``jjtree`` or ``javacc``, you also need to copy them to the ``javacc`` folder.

Copy your source files to the ``src`` folder, and your JUnit test files to the ``test`` folder.

## Compile

To compile the program, run ``gradle build``. This will compile your classes to ``classes/main/java`` and copy the JAR file to the root directory. The JAR file will have the same name as the repository folder.

### Run

To run you have two options: Run the ``.class`` files or run the JAR.

### Run ``.class``

To run the ``.class`` files, do the following:

```cmd
java -cp "./build/classes/java/main/" <class_name> <arguments>
```

Where ``<class_name>`` is the name of the class you want to run and ``<arguments>`` are the arguments to be passed to ``main()``.

### Run ``.jar``

To run the JAR, do the following command:

```cmd
java -jar <jar filename> <arguments>
```

Where ``<jar filename>`` is the name of the JAR file that has been copied to the root folder, and ``<arguments>`` are the arguments to be passed to ``main()``.

#### Debug Mode

In order run the program with the JAR file in Debug Mode and print the Symbol Table to the console, run the following command

```cmd
java -jar <jar filename> <path to jmm file> [ <debug> ]
```

That is:

```cmd
java -jar <jar filename> <path to jmm file> true
```

## Test

To test the program, run ``gradle test``. This will execute the build, and run the JUnit tests in the ``test`` folder. If you want to see output printed during the tests, use the flag ``-i`` (i.e., ``gradle test -i``).

# Semantic Analysis Checklist (Checkpoint 2)

## Symbol Table :heavy_check_mark:

 - [X] **global:** inclui info de imports e a classe declarada
 - [X] **classe-specific:** inclui info de extends, fields e methods
 - [X] **method-specific:** inclui info dos arguments e local variables
 - [X] **Method Overloading:** métodos com mesmo nome mas assinatura de parâmetros diferente
 - [X] **Table Lookups:** tem de permitir consulta da tabela por parte da análise semantica (e geração de código)
 - [X] **Debug Mode:** tem de permitir ligar e desligar a sua impressão para fins de debug (neste caso para fins de avaliação)

## Type Verification

 - [X] **Unary/Binary Operation:** verificar se operações são efetuadas com o mesmo tipo (e.g. int + boolean tem de dar erro)
 - [X] **Array Operations:** não é possível utilizar arrays diretamente para operações aritmeticas (e.g. array1 + array2)
 - [X] **Array Index:** verificar se um array access é de facto feito sobre um array
 - [X] **Array Index:** verificar se o indice do array access é um inteiro
 - [X] **Assignments Types:** verificar se valor do assignee é igual ao do assigned (a_int = b_boolean não é permitido!)
 - [X] **Conditional Expression:** verificar se conditional expressions (if e while) resulta num booleano
 - [X] **Variable Initialization:** verificar se variáveis são inicializadas, dando um WARNING em vez de ERRO
 
## Function Verification
 - [X] **Target Verification** verificar se o "target" do método existe, e se este contém o método (e.g. a.foo, ver se 'a' existe e se tem um método 'foo'); caso seja do tipo da classe declarada (e.g. a usar o this), verificar se é método do extends olhando para o que foi importado (isto se a classe fizer extends de outra classe importada)
 - [X] **Imported Methods:** caso o método não seja da classe declarada, isto é importada, verificar se método foi importado
 - [X] **Parameter List:** verificar se o **número de argumentos** na invocação é igual ao número de parâmetros da declaração
 - [X] **Parameter Type List:** verificar se o **tipo dos parâmetros** coincide com o tipo dos argumentos

## Code Generation
 - [X] **Class Structure:** estrutura básica de classe (incluindo construtor `<init>`)
 - [X] **Field Structure:** estrutura básica de fields
 - [X] **Method Structure:** estrutura básica de métodos (podem desconsiderar os limites neste checkpoint: limit_stack 99, limit_locals 99)
 - [X] **assignments:**
 - [X] **Arithmetic Operations:** operações aritméticas (com prioridade de operações correta), neste checkpoint não é necessário a seleção das operações mais eficientes mas isto será considerado no CP3 e versão final
 - [X] **Method Calls:** invocação de métodos

# Code Generation (Checkpoint 3)

 - [X] **Conditionals:** Generate JVM code accepted by jasmin for conditional instructions(`if` and `if-else`)
 - [X] **Loops:** Generate JVM code accepted by jasmin for loops (`while`)
 - [X] **Arrays:** Generate JVM code accepted by jasmin to deal with arrays
    - [X] Array initialization (`newarray int`)
    - [X] Array Store (`astore`)
    - [X] Array Access (`aload`)
    - [X] Array Position Store (`iastore`)
    - [X] Array Position Access (`iaload`)
 - [X] **Limits:** `.limit stack` and `.limit locals` are calculated
 - [X] **Pass all tests**
 - [X] **Custom tests**
    - [X] Fibonacci
    - [X] Leap Years
    - [X] Factorial (Recursion and Iteration)
    
# Final Delivery

 - [X] **Instruction Selection:** Choose the most optimized instruction (constant loading, variable increments and `<` comparison)
 - [X] **Comments and Documentation:** Document classes and methods, comment key code parts
 - [X] **Tests:** Build more tests showing off compiler features
 - [ ] **README.txt:** Group information, contributions, compiling and execution instructions
 - [ ] **Complete Form:** Eventually
 - [ ] **`-r=<num>`:** Where `<num>` equals the maximum number of available registers
 - [ ] **`-o`:** This option should include the following optimizations:
     - [ ] Replace constant variables with respective values
     - [ ] Don't user `goto`'s on `while` loops


