options
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(Parser)

public class Parser
{
    /**
     * Current number os syntax errors while parsing
     */
    private static int numErrors = 0;

    /**
     * Maximum number of syntax errors accepted before terminating
     * parsing due to too many errors
     */
    private static int MAX_ERRORS = 10;

    /**
    * Main method
    * @param args
    * @throws ParseException
    */
    public static void main(String[] args) throws ParseException {
        System.out.println("Parser for programs in the Java-- language");

        Parser parser;
        // open file as input stream
        try {
            parser = new Parser(new java.io.FileInputStream(args[0]));
        }
        catch (java.io.FileNotFoundException e) {
            System.out.println("ERROR: file " + args[0] + " not found.");
            return;
        }

        SimpleNode root;
        // create Syntax Tree (returns reference to root node)
        try {
            root = parser.Tree();
        }
        catch (ParseException e) {
            System.out.println(e.toString());
            return;
        }

        // Print tree to console
        root.dump("");
    }

    /**
     * Report syntax error and increment error counter
     */
    static void reportError(ParseException e, String statement) {
        System.out.println("Syntax error on " + statement + " statement.\n\n" + e.toString());
        numErrors++;

        if (numErrors >= MAX_ERRORS) {
              System.out.println("Reached maximum number of errors (" + MAX_ERRORS + "). Terminating.");
              System.exit(1);
        }
    }
}

PARSER_END(Parser)

/**
 * Tokens to ignore
 */
SKIP :
{
    < WHITESPACE:      " "                                                         > |
    < TAB:             "\t"                                                        > |
    < CARRIAGE_RETURN: "\r"                                                        > |
    < NEWLINE:         "\n"                                                        > |
    < INLINE_COMMENT:  "//" ( ~[ "\n", "\r" ] )* ( "\n" | "\r" | "\r\n" )          > |
    < BLOCK_COMMENT:   "/*" ( ~[ "*" ] )* "*" ( ~[ "/" ] (~[ "*" ] )* "*")* "/"    >
}

/**
 * Keywords
 */
TOKEN:
{
    < IMPORT:       "import"                         > |
    < EXTENDS:      "extends"                        > |
    < PUBLIC:       "public"                         > |
    < STATIC:       "static"                         > |
    < CLASS:        "class"                          > |
    < RETURN:       "return"                         > |
    < MAIN:         "main"                           > |
    < WHILE:        "while"                          > |
    < IF:           "if"                             > |
    < ELSE:         "else"                           > |
    < NEW:          "new"                            > |
    < THIS:         "this"                           > |
    < LENGTH:       "length"                         > |
    < TRUE:         "true"                           > |
    < FALSE:        "false"                          >
}

/**
 * Variable types
 */
TOKEN:
{
    < VOID:         "void"                           > |
    < INT:          "int"                            > |
    < BOOLEAN:      "boolean"                        > |
    < STRING:       "String"                         >
}

/**
 * Operations
 */
TOKEN:
{
    < ASSIGNMENT:   "="                              > |
    < AND:          "&&"                             > |
    < LT:           "<"                              > |
    < SUM:          "+"                              > |
    < SUB:          "-"                              > |
    < MULT:         "*"                              > |
    < DIV:          "/"                              > |
    < NOT:          "!"                              >
}

/**
 * Code characters
 */
TOKEN:
{
    < COMMA:        ","                              > |
    < DOT:          "."                              > |
    < SEMI_COLON:   ";"                              > |
    < OPEN_BLOCK:   "{"                              > |
    < CLOSE_BLOCK:  "}"                              > |
    < OPEN_ARRAY:   "["                              > |
    < CLOSE_ARRAY:  "]"                              > |
    < OPEN_PAR:     "("                              > |
    < CLOSE_PAR:    ")"                              >
}

/**
 * Integers and identifiers
 */
TOKEN:
{
    < INTEGER:      <BINARY> | <OCTAL> | <DECIMAL> | <HEXADECIMAL>      > |
    < #BINARY:      ( "0b" | "0B" ) ( [ "0"-"1" ] )+                    > |
    < #OCTAL:       "0" ( [ "0"-"7" ] )*                                > |
    < #DECIMAL:     [ "1"-"9" ] ( [ "0"-"9" ] )*                        > |
    < #HEXADECIMAL: ( "0x" | "0X" ) ( [ "0"-"9", "A"-"F", "a"-"f" ] )+  > |

    < IDENTIFIER:   <LETTER> ( <LETTER> | <DIGIT> )*                    > |
    < #LETTER:      [ "$", "_", "a"-"z", "A"-"Z" ]                      > |
    < #DIGIT:       [ "0"-"9" ]                                         >
}


SimpleNode Tree(): {}
{
    Program(1) { return jjtThis; } // Java code inside brackets
}


void Program(int sign): {}
{
    ImportDeclaration()
    ClassDeclaration()
    <EOF>
}


void ImportDeclaration(): {} {
    ( <IMPORT> [ <STATIC> ] <IDENTIFIER> [ ImportMethod() ] <SEMI_COLON> )*
}

void ImportMethod(): {} {
    <DOT> <IDENTIFIER> <OPEN_PAR>
        [ <VOID> | Type() ( <COMMA> Type() )* ] // Nothing | VOID | Types
    <CLOSE_PAR> [ <VOID> | Type() ]
}


void ClassDeclaration(): {}
{
    <CLASS> <IDENTIFIER> [ <EXTENDS> <IDENTIFIER> ] <OPEN_BLOCK>
        ( VarDeclaration() )*
        ( MethodDeclaration() )*
    <CLOSE_BLOCK>
}


void VarDeclaration(): {}
{
    Type() <IDENTIFIER> <SEMI_COLON>
}


void MethodDeclaration(): {} { <PUBLIC> ( RegularMethod() | MainMethod() ) }

void RegularMethod() #void: {} {
    Type() <IDENTIFIER> [ Type() <IDENTIFIER> ( <COMMA> Type() <IDENTIFIER> )* ]
    <OPEN_BLOCK> MethodBody() <RETURN> Expression() <SEMI_COLON> <CLOSE_BLOCK>
}
void MainMethod() #void: {} {
    <STATIC> <VOID> <MAIN> <OPEN_PAR> <STRING> <OPEN_ARRAY> <CLOSE_ARRAY> <IDENTIFIER> <CLOSE_PAR>
    <OPEN_BLOCK> MethodBody() <CLOSE_BLOCK>
}
void MethodBody() #void: {} { ( LOOKAHEAD(2) VarDeclaration() )* ( Statement() )* }


void Type(): {}
{
    <INT> [ <OPEN_ARRAY> <CLOSE_ARRAY> ]    |
    <BOOLEAN>                               |
    <IDENTIFIER>
}


void Statement(): {}
{
    MultiStatementBlock()                               |
    IfElseBlock()                                       |
    WhileBlock()                                        |
    <IDENTIFIER> ( Assignment() | ArrayAssignment() )   |
    Expression() <SEMI_COLON>
}

void MultiStatementBlock() #void: {} { <OPEN_BLOCK> ( Statement() )* <CLOSE_BLOCK> }

void IfElseBlock() : {}
{
    try {
        <IF> <OPEN_PAR> Expression() <CLOSE_PAR> Statement() <ELSE> Statement()
    }
    catch(ParseException e) {
        reportError(e, "if");
    }
}
void WhileBlock() : {}
{
    try {
        <WHILE> <OPEN_PAR> Expression() <CLOSE_PAR> Statement()
    }
    catch(ParseException e) {
        reportError(e, "while");
        // DEEP ERROR RECOVERY
        // The loop consumes tokens all the way up to a token of
        // "kind".  We use a do-while loop rather than a while because the
        // current token is the one immediately before the erroneous token
        // (in our case the token immediately before what should have been
        // "while".
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != CLOSE_PAR);
    }
}

void Assignment() #void: {} { <ASSIGNMENT> Expression() <SEMI_COLON> }
void ArrayAssignment() #void: {} {<OPEN_ARRAY> Expression() <CLOSE_ARRAY> <ASSIGNMENT> Expression() <SEMI_COLON> }


void Expression(): {} {
    SimpleExp() ComplexExp()
}

void ComplexExp() #void: {} {
    [ LOOKAHEAD(2) ExpLink() ComplexExp() ]
}

void ExpLink() #void: {}
{
    CompareOp() Expression()                |
    <OPEN_ARRAY> Expression() <CLOSE_ARRAY> |
    <DOT> ( GetLength() | CallMethod() )
}

void CompareOp() #void: {}
{
    <AND>  |
    <LT>   |
    <SUM>  |
    <SUB>  |
    <MULT> |
    <DIV>
}
void GetLength() #void: {} { <LENGTH> }
void CallMethod() #void: {} {
    <IDENTIFIER> <OPEN_PAR>
        [ Expression() ( <COMMA> Expression() )* ]
    <CLOSE_PAR>
}


void SimpleExp() #void: {}
{
    <INTEGER>                           |
    <TRUE>                              |
    <FALSE>                             |
    <IDENTIFIER>                        |
    <THIS>                              |
    CreateObject()                      |
    <NOT> Expression()                  |
    <OPEN_PAR> Expression() <CLOSE_PAR>
}

void CreateObject() #void: {} { <NEW> ( CreateArray() | CreatePrimitive() ) }
void CreateArray() #void: {} { <INT> <OPEN_ARRAY> Expression() <CLOSE_ARRAY> }
void CreatePrimitive() #void: {} { <IDENTIFIER> <OPEN_PAR> <CLOSE_PAR> }
